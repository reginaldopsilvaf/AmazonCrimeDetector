# -*- coding: utf-8 -*-

"""
/***************************************************************************
 OperaçãoRicardoFranco
                                 A QGIS plugin
 Identificador de Crimes Transfronteiriços utilizando Inteligência Artificial
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-11-21
        copyright            : (C) 2024 by Matheus Alves Silva, Reginaldo Pereira da Silva Filho
        email                : reginaldo.silva@ime.eb.br
                               matheus.silva@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Matheus Alves Silva, Reginaldo Pereira da Silva Filho'
__date__ = '2024-11-21'
__copyright__ = '(C) 2024 by Matheus Alves Silva, Reginaldo Pereira da Silva Filho'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterRasterLayer,
    QgsProcessingParameterFile,
    QgsProcessingParameterNumber,
    QgsProcessingParameterString,
    QgsProcessingParameterRasterDestination
)

import os
import numpy as np
from osgeo import gdal
import tensorflow as tf

class IdentificadorCrimesFronteiras(QgsProcessingAlgorithm):
    INPUT_RASTER = "INPUT_RASTER"
    INPUT_FILE = "INPUT_FILE"
    OUTPUT_RASTER = "OUTPUT_RASTER"
    # CROP_SIZE = 'CROP_SIZE'
    # THRESHOLD = 'THRESHOLD'

    def initAlgorithm(self, config=None):
        # Adiciona o raster de entrada
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_RASTER,
                "Imagem de satélite (PLANET)",
                defaultValue=None
            )
        )

        # Adiciona o arquivo como entrada
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_FILE,
                "Pesos do Modelo de IA treinado",
                behavior=QgsProcessingParameterFile.Folder,
                fileFilter="All Files (*)"
            )
        )

        # Adiciona o raster de saída
        self.addParameter(
            QgsProcessingParameterRasterDestination(
                self.OUTPUT_RASTER,
                "Máscara de predição"
            )
        )

        # self.addParameter(
        #     QgsProcessingParameterNumber(
        #         self.CROP_SIZE,
        #         "Tamanho do patch",
        #         defaultValue=128
        #     )
        # )

        # self.addParameter(
        #     QgsProcessingParameterString(
        #         self.THRESHOLD,
        #         "Limiar de predição (0 a 1)",
        #         defaultValue=1
        #     )
        # )

    def processAlgorithm(self, parameters, context, feedback):
        img = self.parameterAsRasterLayer(parameters, self.INPUT_RASTER, context).dataProvider().dataSourceUri()
        modelo = self.parameterAsFile(parameters, self.INPUT_FILE, context)
        saida = self.parameterAsOutputLayer(parameters, self.OUTPUT_RASTER, context)
        # crop_size = self.parameterAsInt(parameters, self.CROP_SIZE, context)
        # threshold = float(self.parameterAsString(parameters, self.THRESHOLD, context))

        feedback.pushInfo("Chamando script externo para inferência...")

        model = tf.saved_model.load(modelo)
        infer = model.signatures["serving_default"]
        img_ds = gdal.Open(img)
        if img_ds is None:
            raise FileNotFoundError(f"Não foi possível abrir {img}")

        width, height = img_ds.RasterXSize, img_ds.RasterYSize
        geo_transform = img_ds.GetGeoTransform()
        projection = img_ds.GetProjection()

        height = int(height)
        # crop_size = int(crop_size)
        crop_size = 128

        coords = []
        crops = []
        for y in range(0, height - crop_size + 1, crop_size):
            for x in range(0, width - crop_size + 1, crop_size):
                crop = np.stack([
                    img_ds.GetRasterBand(1).ReadAsArray(x, y, crop_size, crop_size),
                    img_ds.GetRasterBand(2).ReadAsArray(x, y, crop_size, crop_size),
                    img_ds.GetRasterBand(3).ReadAsArray(x, y, crop_size, crop_size),
                ], axis=-1)
                crops.append(crop)
                coords.append((y, x))
        img_ds = None

        # Converte a lista de crops para um array numpy já como float32
        crops = np.array(crops, dtype=np.float32) 

        # NORMALIZA O ARRAY INTEIRO DE UMA VEZ!
        crops_normalized = crops / 255.0 

        # Converte para um tensor do TensorFlow (o casting não é mais necessário se o dtype já for float32)
        input_tensor = tf.convert_to_tensor(crops_normalized)
        
        result = infer(input_tensor)

        preds = list(result.values())[0]

        mask = np.zeros((height, width), dtype=np.float32)
        count = np.zeros((height, width), dtype=np.float32)

        for (i, j), pred in zip(coords, preds):
            mask[i:i+crop_size, j:j+crop_size] += tf.squeeze(pred).numpy()
            count[i:i+crop_size, j:j+crop_size] += 1

        count[count == 0] = 1
        mask /= count
        binary_mask = (mask >= 0.5).astype(np.uint8)

        driver = gdal.GetDriverByName("GTiff")
        out_ds = driver.Create(saida, binary_mask.shape[1], binary_mask.shape[0], 1, gdal.GDT_Byte)
        out_ds.SetGeoTransform(geo_transform)
        out_ds.SetProjection(projection)
        out_ds.GetRasterBand(1).WriteArray(binary_mask)
        out_ds.FlushCache()
        out_ds = None

        return {self.OUTPUT_RASTER: saida}
    
    def name(self):
        return "Identificador de Pistas de Garimpo Ilegal na Amazônia"

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return "ProjetoSIMGEO2025"
    
    def tr(self, string):
        return QCoreApplication.translate('Processing', string)
    
    def icon(self):
        """
        Should return a QIcon which is used for your provider inside
        the Processing toolbox.
        """
        icon_path = os.path.join(os.path.dirname(__file__), "icon-orf-resized.png")

        return QIcon(icon_path)
    
    def shortHelpString(self):
        help_text = """               
        Essa ferramenta cria uma máscara de predição que identifica áreas com indícios de garimpo ilegal na Floresta Amazônica a partir da imagem de satélite RGB (Imagem Planet) e os pesos treinados da rede neural U-Net com encoder MobileNetV2 pré-treinado (https://github.com/reginaldopsilvaf/AmazonCrimeDetector)
        
        Tal aplicação foi desenvolvida para ser apresentada no SIMGEO 2025, realizada em Recife entre as datas de 23/12/2025 e 25/12/2025.
        
        Desenvolvida por: Matheus Alves Silva, Reginaldo Pereira da Silva Filho
        Version: 0.1
        Date: 12-07-2025
        email: matheus.silva@ime.eb.br, reginaldo.filho@ime.eb.br
        """
        return self.tr(help_text)

    def createInstance(self):
        return IdentificadorCrimesFronteiras()
